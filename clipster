#!/usr/bin/python

"""Clipster - Clipboard manager."""

# pylint: disable=line-too-long

from __future__ import print_function
from gi import require_version
require_version("Gtk", "3.0")
from gi.repository import Gtk, Gdk, GLib, GObject
import signal
import argparse
import json
import socket
import os
import errno
import sys
import select
import logging
import tempfile
import re
try:
    # py 3.x
    import configparser
except ImportError:
    # py 2.x
    import ConfigParser as configparser


class Clipster(object):
    """Clipboard Manager."""

    def __init__(self, config):
        self.config = config
        self.stdin = ""
        if not sys.stdin.isatty():
            if sys.stdin in select.select([sys.stdin], [], [], 0)[0]:
                self.stdin = sys.stdin.read()

    def client(self, client_action):
        """Send a signal and (optional) data from STDIN to daemon socket."""

        message = "{0}:{1}:{2}".format(client_action,
                                       self.config.get('clipster',
                                                       'default_selection'),
                                       self.stdin)

        logging.debug("Connecting to server socket.")
        sock_c = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        try:
            sock_c.connect(self.config.get('clipster', "socket_file"))
        except socket.error:
            logging.error("Error connecting to socket. Is daemon running?")
            sys.exit(1)
        logging.debug("Sending message: %s", message)
        sock_c.sendall(message.encode('utf-8'))
        data = []
        while True:
            try:
                recv = sock_c.recv(8192)
                logging.debug("Received data from server.")
                if not recv:
                    break
                data.append(recv.decode('utf-8'))
            except socket.error:
                break
        sock_c.close()
        if data:
            print(''.join(data), end='')

    class Daemon(object):
        """Handles clipboard events, client requests, stores history."""

        # pylint: disable=too-many-instance-attributes

        def __init__(self, config):
            """Set up clipboard objects and history dict."""
            self.config = config
            self.patterns = None
            self.window = self.p_id = self.c_id = self.sock_s = None
            self.sock_file = self.config.get('clipster', 'socket_file')
            self.primary = Gtk.Clipboard.get(Gdk.SELECTION_PRIMARY)
            self.clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)
            self.boards = {"PRIMARY": [""], "CLIPBOARD": [""]}
            self.hist_file = self.config.get('clipster', 'history_file')
            self.pid_file = self.config.get('clipster', 'pid_file')
            self.max_input = self.config.getint('clipster', 'max_input')
            # Flag to indicate that the in-memory history should be flushed to disk
            self.update_history_file = False

        def keypress_handler(self, widget, event):
            """Handler for selection_widget keypress events."""

            # Hide window if ESC is pressed
            if event.keyval == Gdk.KEY_Escape:
                self.window.hide()

        def selection_handler(self, tree, path, col, board):
            """Handler for selection widget 'select' event."""

            # Get selection
            model, treeiter = tree.get_selection().get_selected()
            # Select full text from row
            data = model[treeiter][1]
            self.update_board(board, data)
            model.clear()
            self.window.hide()

        def selection_widget(self, board):
            """GUI window for selecting items from clipboard history."""

            # Create windows & widgets
            # Gtk complains about dialogs with no parents, so create one
            rootwin = Gtk.Window()
            self.window = Gtk.Dialog(title="Clipster", parent=rootwin)
            scrolled = Gtk.ScrolledWindow()
            model = Gtk.ListStore(str, str)
            tree = Gtk.TreeView(model)
            renderer = Gtk.CellRendererText()
            column = Gtk.TreeViewColumn("{0} clipboard:".format(board),
                                        renderer, markup=0)

            # Add rows to the model
            for item in self.boards[board][::-1]:
                label = GLib.markup_escape_text(item)
                row_height = self.config.getint('clipster', 'row_height')
                trunc = ""
                lines = label.splitlines(True)
                if len(lines) > row_height:
                    trunc = "<b><i>({0} more lines)</i></b>".format(len(lines) - row_height)
                label = "{0}{1}".format(''.join(lines[:row_height]), trunc)
                # Add label and full text to model
                model.append([label, item])

            # Handle keypresses (looking for escape key)
            self.window.connect("key-press-event", self.keypress_handler)
            # Row is clicked on, or enter pressed
            tree.connect("row-activated", self.selection_handler, board)

            # Format, connect and show windows
            # Allow alternating color for rows, if WM theme supports it
            tree.set_rules_hint(True)
            # Draw horizontal divider lines between rows
            tree.set_grid_lines(Gtk.TreeViewGridLines.HORIZONTAL)

            tree.append_column(column)
            scrolled.add(tree)
            # GtkDialog comes with a vbox already active, so pack into this
            self.window.vbox.pack_start(scrolled, True, True, 0)
            self.window.set_size_request(500, 500)
            self.window.show_all()

        def read_history_file(self):
            """Read clipboard history from file."""
            try:
                with open(self.hist_file, 'r') as hist_f:
                    self.boards.update(json.load(hist_f))
            except IOError as exc:
                if exc.errno == errno.ENOENT:
                    # Not an error if there is no history file
                    pass

        def write_history_file(self):
            """Write clipboard history to file."""

            if self.update_history_file:
                logging.debug("Writing history to file.")
                tmp_fd, tmp_name = tempfile.mkstemp(dir=self.config.get('clipster', 'clipster_dir'))
                # Limit history file to contain last 'history_size' items
                limit = self.config.getint('clipster', 'history_size')
                hist = {x: y[-limit:] for x, y in self.boards.items()}
                os.write(tmp_fd, json.dumps(hist).encode('utf-8'))
                os.rename(tmp_name, self.hist_file)
                self.update_history_file = False
            else:
                logging.debug("History unchanged - not writing to file.")
            # Return true to make the timeout handler recur
            return True


        def update_board(self, board, data):
            """Update a clipboard."""

            getattr(self, board.lower()).set_text(data, -1)

        def de_duplicate(self, board, text):
            """If an text already exists in the clipboard, remove it."""

            if not self.config.getboolean('clipster', 'duplicates'):
                if text in self.boards[board]:
                    logging.debug("duplicate: removing.")
                    self.boards[board].remove(text)

        def update_history(self, board, text):
            """Update the in-memory clipboard history."""

            logging.debug("Updating clipboard: %s", board)

            try:
                # Needed for unicode comparisons - see issue #1
                text = text.decode('utf-8')
            except (UnicodeDecodeError, AttributeError):
                pass

            self.de_duplicate(board, text)
            diff = self.config.getint('clipster', 'smart_update')
            for pos in range(1, diff+1):
                if text[:-pos] == self.boards[board][-1] or text == self.boards[board][-1][:-pos]:
                    logging.debug("smart-update: removing.")
                    # new selection is a longer/shorter version of previous
                    self.boards[board].pop()
            if self.patterns:
                for pattern in self.patterns:
                    try:
                        for match in set(re.findall(pattern, text)):
                            if match != text:
                                logging.debug("Pattern '%s' matched in: %s", pattern, text)
                                self.de_duplicate(board, match)
                                self.boards[board].append(match)
                    except re.error as exc:
                        logging.warn("Skipping invalid pattern '%s': %s", pattern, exc.message)
            if self.config.getboolean('clipster', 'extract_uris'):
                # Simple uri regex
                url_re = r'\S+://\S+'
                for url in set(re.findall(url_re, text)):
                    if url != text:
                        logging.debug("URL found: %s", url)
                        self.de_duplicate(board, url)
                        self.boards[board].append(url)
            if self.config.getboolean('clipster', 'extract_emails'):
                # Simple email regex
                mail_re = r'\S+\@\S+\.\S+'
                for email in set(re.findall(mail_re, text)):
                    # Skip urls with auth info that look a bit like emails
                    # e.g. http://bob:passwd@example.com
                    if ':' not in email:
                        if email != text:
                            logging.debug("Email found: %s", email)
                            self.de_duplicate(board, email)
                            self.boards[board].append(email)

            self.boards[board].append(text)
            # Flag that the history file needs updating
            self.update_history_file = True
            if self.config.getboolean('clipster', 'write_on_change'):
                self.write_history_file()
            logging.debug(self.boards[board])

        def owner_change(self, board, event):
            """Handler for owner-change clipboard events."""

            logging.debug("owner-change event!")
            selection = str(event.selection)
            logging.debug("selection: %s", selection)
            if selection == "PRIMARY":
                event_id = self.p_id
            else:
                event_id = self.c_id
            # Some apps update primary during mouse drag (chrome)
            # Block at start to prevent repeated triggering
            board.handler_block(event_id)
            # FIXME: this devs hack is a bit verbose. Look instead at
            # gdk_seat_get_pointer -> gdk_device_get_state
            # once GdkSeat is in stable
            mouse = None
            for dev in self.window.get_display().get_device_manager().list_devices(Gdk.DeviceType.MASTER):
                if dev.get_source() == Gdk.InputSource.MOUSE:
                    mouse = dev
                    break
            while Gdk.ModifierType.BUTTON1_MASK & self.window.get_root_window().get_device_position(mouse)[3]:
                # Do nothing while mouse button is held down (selection drag)
                pass

            text = ""
            # Read clipboard
            if event.reason != Gdk.OwnerChange.NEW_OWNER:
                # CLOSE or DESTROY event
                logging.debug("Clipboard cleared. Reinstating from history.")
                self.update_board(selection, self.boards[selection][-1])
            elif board.wait_is_text_available():
                logging.debug("Selection is text.")
                text = board.wait_for_text()
                if text:
                    self.update_history(selection, text)
                else:
                    logging.debug("Selection empty. Reinstating from history.")
                    self.update_board(selection, self.boards[selection][-1])
            else:
                logging.debug("Selection is not text - ignoring.")

            # Unblock event handling
            board.handler_unblock(event_id)

        def socket_listen(self, sock_s, _):
            """Establish a socket listening for client connections."""

            conn, _ = sock_s.accept()
            conn.setblocking(0)
            data = []
            recv_total = 0
            while True:
                try:
                    recv = conn.recv(8192)
                    logging.debug("Client connection received.")
                    if not recv:
                        break
                    data.append(recv.decode('utf-8'))
                    recv_total += len(recv)
                    if recv_total > self.max_input:
                        break
                except socket.error:
                    break
            if data:
                logging.debug("Data received.")
                sent = ''.join(data)
                sig, board, content = sent.split(':', 2)
                logging.debug("Received sig: %s", sig)
                logging.debug("Received board: %s", board)
                if sig == "SELECT":
                    self.selection_widget(board)
                elif sig == "BOARD":
                    if content:
                        logging.debug("Received content: %s", content)
                        self.update_board(board, content)
                    else:
                        logging.debug("Sending latest selection entry: %s",
                                      self.boards[board][-1])
                        conn.sendall(self.boards[board][-1].encode('utf-8'))
            conn.close()
            return True

        def prepare_files(self):
            """Ensure that all files and sockets used
            by the daemon are available."""

            # Create the clipster dir if necessary
            try:
                os.makedirs(self.config.get('clipster', 'clipster_dir'))
            except OSError as exc:
                if exc.errno == errno.EEXIST:
                    # ok if directory already exists
                    pass

            # check for existing pid_file, and tidy up if appropriate
            try:
                with open(self.pid_file, 'r') as runf_r:
                    pid = int(runf_r.read())
                    try:
                        # Do nothing, but raise an error if no such process
                        os.kill(pid, 0)
                        logging.error("Daemon already running: pid %s", pid)
                        sys.exit(1)
                    except OSError:
                        try:
                            os.unlink(self.pid_file)
                        except IOError as exc:
                            if exc.errno == errno.ENOENT:
                                # File already gone
                                pass
                            else:
                                raise
            except IOError as exc:
                if exc.errno == errno.ENOENT:
                    pass

            # Create pid file
            with open(self.pid_file, 'w') as runf_w:
                runf_w.write(str(os.getpid()))

            # Read in history from file
            self.read_history_file()

            # Create the socket
            try:
                os.unlink(self.sock_file)
            except OSError as exc:
                if exc.errno == errno.ENOENT:
                    pass

            self.sock_s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            self.sock_s.setblocking(0)
            self.sock_s.bind(self.sock_file)
            self.sock_s.listen(5)

            # Read in patterns file
            if self.config.getboolean('clipster', 'extract_patterns'):
                try:
                    patfile = os.path.join(self.config.get('clipster', 'clipster_dir'), 'patterns')
                    with open(patfile, 'r') as pat_f:
                        self.patterns = [x.strip() for x in pat_f.read().splitlines()]
                        logging.debug("Loaded patterns: %s", ','.join(self.patterns))

                except IOError as exc:
                    logging.warn("Unable to read patterns file: %s %s", patfile, exc.strerror)



        def exit(self):
            """Clean up things before exiting."""

            logging.debug("Daemon exiting...")
            try:
                os.unlink(self.sock_file)
            except OSError:
                logging.warning("Failed to remove socket file: %s", self.sock_file)
            try:
                os.unlink(self.pid_file)
            except OSError:
                logging.warning("Failed to remove run file: %s", self.pid_file)
            try:
                self.write_history_file()
            except OSError:
                logging.warning("Failed to upodate history file: %s", self.hist_file)
            sys.exit(0)

        def run(self):
            """Launch the clipboard manager daemon.
            Listen for clipboard events & client socket connections."""

            # Set up socket, pid file etc
            self.prepare_files()

            # We need to get the display instance from the window
            # for use in obtaining mouse state.
            # POPUP windows can do this without having to first show the window
            self.window = Gtk.Window(type=Gtk.WindowType.POPUP)

            # Handle clipboard changes
            self.p_id = self.primary.connect('owner-change',
                                             self.owner_change)
            self.c_id = self.clipboard.connect('owner-change',
                                               self.owner_change)
            # Handle socket connections
            GObject.io_add_watch(self.sock_s, GObject.IO_IN,
                                 self.socket_listen)
            # Handle unix signals
            GLib.unix_signal_add(GLib.PRIORITY_HIGH, signal.SIGINT, self.exit)
            GLib.unix_signal_add(GLib.PRIORITY_HIGH, signal.SIGTERM, self.exit)

            # Timeout for flushing history to disk
            # Do nothing if timeout is 0, or write_on_change is set in config
            history_timeout = self.config.getint('clipster', 'history_update_interval')
            if history_timeout and not self.config.getboolean('clipster', 'write_on_change'):
                logging.debug("Writing history file every %s seconds", history_timeout)
                GObject.timeout_add_seconds(history_timeout,
                                            self.write_history_file)

            Gtk.main()


def parse_args(clipster_dir):
    """Parse command-line arguments."""

    # Set a default config file
    config_file = os.path.join(clipster_dir, "config")

    parser = argparse.ArgumentParser(description='Clipster clipboard manager.')
    parser.add_argument('-f', '--config', action="store",
                        default=config_file,
                        help="Path to config file.")
    parser.add_argument('-l', '--log_level', action="store", default="INFO",
                        help="Set log level: DEBUG, INFO (default), WARNING, ERROR, CRITICAL")
    parser.add_argument('-p', '--primary', action="store_true",
                        help="Query, or write STDIN to, the PRIMARY clipboard.")
    parser.add_argument('-c', '--clipboard', action="store_true",
                        help="Query, or write STDIN to, the CLIPBOARD clipboard.")
    parser.add_argument('-d', '--daemon', action="store_true",
                        help="Launch the daemon.")
    parser.add_argument('-s', '--select', action="store_true",
                        help="Launch the clipboard history selection window.")

    return parser.parse_args()


def parse_config(args, clipster_dir):
    """Configuration derived from defaults & file."""

    # Set some config defaults
    config_defaults = {"clipster_dir": clipster_dir,  # clipster 'root' dir
                       "default_selection": "PRIMARY",  # PRIMARY or CLIPBOARD
                       "history_file": "%(clipster_dir)s/history",
                       "history_size": "200",  # Number of items to be saved in the history file (for each selection)
                       "history_update_interval": "60", # Flush history to disk every N seconds, if changed (0 disables timeout)
                       "write_on_change": "no", # Always write history file immediately (overrides history_update_interval)
                       "socket_file": "%(clipster_dir)s/clipster_sock",
                       "pid_file":  "%(clipster_dir)s/clipster.pid",
                       "max_input": "50000",  # max length of selection input
                       "row_height": "3",  # num rows to show in widget
                       "duplicates": "no",  # allow duplicates, or instead move the original entry to top
                       "smart_update": "1",  # Replace rather than append is selection is similar to previous
                       "extract_uris": "yes",  # Extract uris within selection text
                       "extract_emails": "yes",  # Extract emails within selection text
                       "extract_patterns": "no"} # Extract patterns based on regexes stored in clipster_dir/patterns (one per line).

    config = configparser.SafeConfigParser(config_defaults)
    config.add_section('clipster')

    # Try to read config file (either passed in, or default value)
    if args.config:
        logging.debug("Trying to read config file: %s", args.config)
        config.read(args.config)

    logging.debug("Merged config: %s",
                  sorted(dict(config.items('clipster')).items()))

    # Override clipdir, if it's an option in the config file
    try:
        clipdir = config.get('clipster', 'clipster_dir')
    except configparser.Error:
        # Otherwise, set the value back into the config
        config.set('clipster', 'clipster_dir', clipdir)

    return config


def main():
    """Start the application."""

    # Set a default directory for clipster files
    clipster_dir = os.path.join(os.environ.get('HOME'), ".clipster")

    # Parse command-line arguments
    args = parse_args(clipster_dir)

    # Enable logging
    logging.basicConfig(format='%(levelname)s:%(message)s',
                        level=getattr(logging, args.log_level.upper()))
    logging.debug("Debugging Enabled.")

    config = parse_config(args, clipster_dir)

    clipster = Clipster(config)

    # Launch the daemon
    if args.daemon:
        clipster.Daemon(config).run()

    client_action = "BOARD"
    if args.select:
        client_action = "SELECT"

    if args.primary:
        config.set('clipster', 'default_selection', 'PRIMARY')
    elif args.clipboard:
        config.set('clipster', 'default_selection', 'CLIPBOARD')

    clipster.client(client_action)


if __name__ == "__main__":
    main()
