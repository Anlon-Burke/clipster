#!/usr/bin/python

"""Clipster - Clipboard manager."""

from __future__ import print_function
from gi.repository import Gtk, Gdk, GLib, GObject
import signal
import argparse
import json
import socket
import os
import errno
import sys
import select
import logging
try:
    # py 3.x
    import configparser
except ImportError:
    # py 2.x
    import ConfigParser as configparser


class Clipster(object):
    """Clipboard Manager."""

    def __init__(self, config):
        self.config = config
        self.stdin = ""
        if not sys.stdin.isatty():
            if sys.stdin in select.select([sys.stdin], [], [], 0)[0]:
                self.stdin = sys.stdin.read()

    def client(self, client_action):
        """Send a signal and (optional) data from STDIN to daemon socket."""

        message = "{0}:{1}:{2}".format(client_action,
                                       self.config.get('clipster',
                                                       'default_selection'),
                                       self.stdin)

        logging.debug("Connecting to server socket.")
        sock_c = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        try:
            sock_c.connect(self.config.get('clipster', "socket_file"))
        except socket.error:
            logging.error("Error connecting to daemon socket. Is daemon running?")
            sys.exit(1)
        logging.debug("Sending message: {0}".format(message))
        sock_c.sendall(message.encode('utf-8'))
        data = []
        while True:
            try:
                recv = sock_c.recv(8192)
                logging.debug("Received data from server.")
                if not recv:
                    break
                data.append(recv.decode('utf-8'))
            except socket.error:
                break
        sock_c.close()
        if data:
            print(''.join(data), end='')

    class Daemon(object):
        """Handles clipboard events, client requests, stores history."""

        def __init__(self, config):
            """Set up clipboard objects and history dict."""
            self.config = config
            self.window = self.p_id = self.c_id = self.sock_s = None
            self.sock_file = self.config.get('clipster', 'socket_file')
            self.primary = Gtk.Clipboard.get(Gdk.SELECTION_PRIMARY)
            self.clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)
            self.boards = {"PRIMARY": [""], "CLIPBOARD": [""]}
            self.hist_file = self.config.get('clipster', 'history_file')
            self.pid_file = self.config.get('clipster', 'pid_file')
            self.max_input = self.config.getint('clipster', 'max_input')

        def keypress_handler(self, widget, event):
            """Handler for selection_widget keypress events."""

            # Hide window if ESC is pressed
            if event.keyval == Gdk.KEY_Escape:
                self.window.hide()

        def selection_handler(self, tree, path, col, board):
            """Handler for selection widget 'select' event."""

            # Get selection
            model, treeiter = tree.get_selection().get_selected()
            # Select full text from row
            data = model[treeiter][1]
            self.update_board(board, data)
            model.clear()
            self.window.hide()

        def selection_widget(self, board):
            """GUI window for selecting items from clipboard history."""

            # Create windows & widgets
            # Gtk complains about dialogs with no parents, so create one
            rootwin = Gtk.Window()
            self.window = Gtk.Dialog(title="Clipster", parent=rootwin)
            scrolled = Gtk.ScrolledWindow()
            model = Gtk.ListStore(str, str)
            tree = Gtk.TreeView(model)
            renderer = Gtk.CellRendererText()
            column = Gtk.TreeViewColumn("{0} clipboard:".format(board),
                                        renderer, markup=0)

            # Add rows to the model
            for item in self.boards[board][::-1]:
                label = item
                row_height = self.config.getint('clipster', 'row_height')
                trunc = ""
                lines = item.splitlines(True)
                if len(lines) > row_height:
                    trunc = "<b><i>({0} more lines)</i></b>".format(len(lines) - row_height)
                label = "{0}{1}".format(''.join(lines[:row_height]), trunc)
                # Add label and full text to model
                model.append([label, item])

            # Handle keypresses (looking for escape key)
            self.window.connect("key-press-event", self.keypress_handler)
            # Row is clicked on, or enter pressed
            tree.connect("row-activated", self.selection_handler, board)

            # Format, connect and show windows
            # Allow alternating color for rows, if WM theme supports it
            tree.set_rules_hint(True)
            # Draw horizontal divider lines between rows
            tree.set_grid_lines(Gtk.TreeViewGridLines.HORIZONTAL)

            tree.append_column(column)
            scrolled.add(tree)
            # GtkDialog comes with a vbox already active, so pack into this
            self.window.vbox.pack_start(scrolled, True, True, 0)
            self.window.set_size_request(500, 500)
            self.window.show_all()

        def read_history_file(self):
            """Read clipboard history from file."""
            try:
                with open(self.hist_file, 'r') as hist_f:
                    self.boards.update(json.load(hist_f))
            except IOError as exc:
                if exc.errno == errno.ENOENT:
                    # Not an error if there is no history file
                    pass

        def write_history_file(self):
            """Write clipboard history to file."""

            logging.debug("Writing history to file.")
            with open(self.hist_file, 'w') as hist_f:
                json.dump(self.boards, hist_f)

        def update_board(self, board, data):
            """Update a clipboard."""

            getattr(self, board.lower()).set_text(data, -1)

        def update_history(self, board, text):
            """Update the in-memory clipboard history."""

            logging.debug("Updating clipboard:{0}".format(board))
            if not self.config.getboolean('clipster', 'duplicates'):
                # If an item already exists in the clipboard, remove it
                if text in self.boards[board]:
                    logging.debug("duplicate: removing.")
                    self.boards[board].remove(text)
            diff = self.config.getint('clipster', 'smart_update')
            for pos in range(1, diff+1):
                if text[:-pos] == self.boards[board][-1] or text == self.boards[board][-1][:-pos]:
                    logging.debug("smart-update: removing.")
                    # new selection is a longer/shorter version of previous
                    self.boards[board].pop()
            self.boards[board].append(text)
            logging.debug(self.boards[board])

        def owner_change(self, board, event):
            """Handler for owner-change clipboard events."""

            logging.debug("owner-change event!")
            selection = str(event.selection)
            logging.debug("selection: {0}".format(selection))
            if selection == "PRIMARY":
                event_id = self.p_id
            else:
                event_id = self.c_id
            # Some apps update primary during mouse drag (chrome)
            # Block at start to prevent repeated triggering
            board.handler_block(event_id)
            # FIXME: this devs hack is a bit verbose. Look instead at
            # gdk_seat_get_pointer -> gdk_device_get_state
            # once GdkSeat is in stable
            mouse = None
            for dev in self.window.get_display().get_device_manager().list_devices(Gdk.DeviceType.MASTER):
                if dev.get_source() == Gdk.InputSource.MOUSE:
                    mouse = dev
                    break
            while Gdk.ModifierType.BUTTON1_MASK & self.window.get_root_window().get_device_position(mouse)[3]:
                # Do nothing while mouse button is held down (selection drag)
                pass

            # Read clipboard
            text = board.wait_for_text()
            if text:
                self.update_history(selection, text)
            else:
                logging.debug("Selection released. Reinstating from history.")
                self.update_board(selection, self.boards[selection][-1])
            # Unblock event handling
            board.handler_unblock(event_id)
            return text

        def socket_listen(self, sock_s, _):
            """Establish a socket listening for client connections."""

            conn, _ = sock_s.accept()
            conn.setblocking(0)
            data = []
            recv_total = 0
            while True:
                try:
                    recv = conn.recv(8192)
                    logging.debug("Client connection received.")
                    if not recv:
                        break
                    data.append(recv.decode('utf-8'))
                    recv_total += len(recv)
                    if recv_total > self.max_input:
                        break
                except socket.error:
                    break
            if data:
                logging.debug("Data received.")
                sent = ''.join(data)
                sig, board, content = sent.split(':', 2)
                if sig == "SELECT":
                    logging.debug("Received sig: SELECT")
                    logging.debug("Received board: {0}".format(board))
                    self.selection_widget(board)
                elif sig == "BOARD":
                    logging.debug("Received sig: BOARD")
                    logging.debug("Received board: {0}".format(board))
                    if content:
                        logging.debug("Received content: {0}".format(content))
                        self.update_board(board, content)
                    else:
                        logging.debug("Sending latest selection entry: {0}".format(self.boards[board][-1]))
                        conn.sendall(self.boards[board][-1].encode('utf-8'))
            conn.close()
            return True

        def prepare_files(self):
            """Ensure that all files and sockets used
            by the daemon are available."""

            # check for existing pid_file, and tidy up if appropriate
            try:
                with open(self.pid_file, 'r') as runf_r:
                    pid = int(runf_r.read())
                    try:
                        # Do nothing, but raise an error if no such process
                        os.kill(pid, 0)
                        logging.error("Daemon already running: pid {0}".format(pid))
                        sys.exit(1)
                    except OSError:
                        try:
                            os.unlink(self.pid_file)
                        except IOError as exc:
                            if exc.errno == errno.ENOENT:
                                # File already gone
                                pass
                            else:
                                raise
            except IOError as exc:
                if exc.errno == errno.ENOENT:
                    pass

            # Create pid file
            with open(self.pid_file, 'w') as runf_w:
                runf_w.write(str(os.getpid()))

            # Create the clipster dir if necessary
            try:
                os.makedirs(self.config.get('clipster', 'clipster_dir'))
            except OSError as exc:
                if exc.errno == errno.EEXIST:
                    # ok if directory already exists
                    pass

            # Read in history from file
            self.read_history_file()

            # Create the socket
            try:
                os.unlink(self.sock_file)
            except OSError as exc:
                if exc.errno == errno.ENOENT:
                    pass

            self.sock_s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            self.sock_s.setblocking(0)
            self.sock_s.bind(self.sock_file)
            self.sock_s.listen(5)

        def exit(self):
            """Clean up things before exiting."""

            logging.debug("Daemon exiting...")
            try:
                os.unlink(self.sock_file)
            except OSError:
                logging.warning("Failed to remove socket file: {0}".format(self.sock_file))
            try:
                os.unlink(self.pid_file)
            except OSError:
                logging.warning("Failed to remove run file: {0}".format(self.pid_file))
            self.write_history_file()
            sys.exit(0)

        def run(self):
            """Launch the clipboard manager daemon.
            Listen for clipboard events & client socket connections."""

            # Set up socket, pid file etc
            self.prepare_files()

            # We need to get the display instance from the window
            # for use in obtaining mouse state.
            # POPUP windows can do this without having to first show the window
            self.window = Gtk.Window(type=Gtk.WindowType.POPUP)

            # Handle clipboard changes
            self.p_id = self.primary.connect('owner-change',
                                             self.owner_change)
            self.c_id = self.clipboard.connect('owner-change',
                                               self.owner_change)
            # Handle socket connections
            GObject.io_add_watch(self.sock_s, GObject.IO_IN,
                                 self.socket_listen)
            # Handle unix signals
            GLib.unix_signal_add(GLib.PRIORITY_HIGH, signal.SIGINT, self.exit)
            GLib.unix_signal_add(GLib.PRIORITY_HIGH, signal.SIGTERM, self.exit)
            Gtk.main()


def main():
    """Start the application."""

    # Set a default config file
    clipster_dir = os.path.join(os.environ.get('HOME'), ".clipster")
    config_file = os.path.join(clipster_dir, "config")

    parser = argparse.ArgumentParser(description='Clipster clipboard manager.')
    parser.add_argument('-f', '--config', action="store",
                        default=config_file,
                        help="Path to config file.")
    parser.add_argument('-l', '--log_level', action="store", default="INFO",
                        help="Set log level: DEBUG, INFO (default), WARNING, ERROR, CRITICAL")
    parser.add_argument('-p', '--primary', action="store_true",
                        help="Query, or write STDIN to, the PRIMARY clipboard.")
    parser.add_argument('-c', '--clipboard', action="store_true",
                        help="Query, or write STDIN to, the CLIPBOARD clipboard.")
    parser.add_argument('-d', '--daemon', action="store_true",
                        help="Launch the daemon.")
    parser.add_argument('-s', '--select', action="store_true",
                        help="Launch the clipboard history selection window.")

    args = parser.parse_args()

    logging.basicConfig(format='%(levelname)s:%(message)s',
                        level=getattr(logging, args.log_level.upper()))
    logging.debug("Debugging Enabled.")

    # Set some config defaults
    config_defaults = {"clipster_dir": clipster_dir,  # clipster 'root' dir
                       "default_selection": "PRIMARY",  # PRIMARY or CLIPBOARD
                       "history_file": "%(clipster_dir)s/history",
                       "socket_file": "%(clipster_dir)s/clipster_sock",
                       "pid_file":  "%(clipster_dir)s/clipster.pid",
                       "max_input": "50000",  # max length of selection input
                       "row_height": "3",  # num rows to show in widget
                       "duplicates": "no",  # allow duplicates, or instead move the original entry to top
                       "smart_update": "1"}  # Replace rather than append is selection is similar to previous

    config = configparser.SafeConfigParser(config_defaults)
    config.add_section('clipster')

    # Try to read config file (either passed in, or default value)
    if args.config:
        logging.debug("Trying to read config file: {0}".format(args.config))
        config.read(args.config)

    logging.debug("Merged config: {0}".format(sorted(dict(config.items('clipster')).items())))

    # Override clipdir, if it's an option in the config file
    try:
        clipdir = config.get('clipster', 'clipster_dir')
    except configparser.Error:
        # Otherwise, set the value back into the config
        config.set('clipster', 'clipster_dir', clipdir)

    clipster = Clipster(config)

    # Launch the daemon
    if args.daemon:
        clipster.Daemon(config).run()

    client_action = "BOARD"
    if args.select:
        client_action = "SELECT"

    if args.primary:
        config.set('clipster', 'default_selection', 'PRIMARY')
    elif args.clipboard:
        config.set('clipster', 'default_selection', 'CLIPBOARD')

    clipster.client(client_action)


if __name__ == "__main__":
    main()
